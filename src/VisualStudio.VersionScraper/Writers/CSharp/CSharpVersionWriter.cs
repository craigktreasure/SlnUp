namespace VisualStudio.VersionScraper.Writers.CSharp;

using System.Diagnostics.CodeAnalysis;
using System.IO.Abstractions;

using SlnUp.Core;

using Treasure.Utils;

internal sealed class CSharpVersionWriter
{
    private const string ClassName = "VersionManager";

    private const string GetVersionsMethodName = "GetDefaultVersions";

    private const string NamespaceName = "SlnUp.Core";

    private readonly IFileSystem fileSystem;
    public CSharpVersionWriter(IFileSystem fileSystem) => this.fileSystem = Argument.NotNull(fileSystem);

    public void WriteClassToFile(IEnumerable<VisualStudioVersion> versions, string filePath)
    {
        using StreamWriter streamWriter = this.fileSystem.File.CreateText(filePath);
        CodeWriter writer = new(streamWriter);
        WriteHeader(writer);
        writer.WriteLine();
        WriteClass(writer, versions);
    }

    private static void WriteClass(CodeWriter writer, IEnumerable<VisualStudioVersion> versions)
    {
        writer.WriteLine($"namespace {NamespaceName};");
        writer.WriteLine();
        writer.WriteLine($"public partial class {ClassName}");
        using (writer.WithBrackets())
        {
            WriteLatestVersions(writer);
            writer.WriteLine();
            WriteGetVersionsMethod(writer, versions);
        }
    }

    [SuppressMessage("Globalization", "CA1304:Specify CultureInfo")]
    private static void WriteGetVersionsMethod(CodeWriter writer, IEnumerable<VisualStudioVersion> versions)
    {
        writer.WriteLines(@"
/// <summary>
/// Gets the default versions.
/// </summary>
/// <returns><see cref=""IReadOnlyList{VisualStudioVersion}""/>.</returns>");
        writer.WriteLine($"public static IReadOnlyList<{nameof(VisualStudioVersion)}> {GetVersionsMethodName}()");
        using (writer.WithBrackets())
        {
            writer.WriteLine("return new []");

            using (writer.WithBrackets(closingSemicolon: true))
            {
                foreach (VisualStudioVersion version in versions)
                {
                    string isPreview = version.IsPreview ? "true" : "false";
                    writer.WriteLine($"new {nameof(VisualStudioVersion)}({nameof(VisualStudioProduct)}.{version.Product}, Version.Parse(\"{version.Version}\"), Version.Parse(\"{version.BuildVersion}\"), \"{version.Channel}\", {isPreview}),");
                }
            }
        }
    }

    private static void WriteHeader(CodeWriter writer)
    {
        writer.WriteLines($@"
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool on {ThisAssembly.GitCommitDate:d}.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------");
    }

    private static void WriteLatestVersions(CodeWriter writer)
    {
        VisualStudioProduct latestProduct = Enum.GetValues<VisualStudioProduct>().Max();
        writer.WriteLines(@"
/// <summary>
/// The latest product.
/// </summary>");
        writer.WriteLine($"public const {nameof(VisualStudioProduct)} LatestProduct = {nameof(VisualStudioProduct)}.{latestProduct};");
        writer.WriteLine();
        writer.WriteLines(@"
/// <summary>
/// The latest product value.
/// </summary>");
        writer.WriteLine($"public const string LatestProductValue = \"{(int)latestProduct}\";");
    }
}
